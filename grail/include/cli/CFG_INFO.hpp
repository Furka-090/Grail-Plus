/*
 * CFG_INFO.hpp
 *
 *  Created on: Feb 14, 2012
 *      Author: petergoodman
 *     Version: $Id$
 */

#ifndef Grail_Plus_CFG_INFO_HPP_
#define Grail_Plus_CFG_INFO_HPP_

#include <cstdio>

#include "fltl/include/CFG.hpp"

#include "grail/include/io/CommandLineOptions.hpp"
#include "grail/include/io/fread_cfg.hpp"
#include "grail/include/io/fprint_cfg.hpp"

#include "grail/include/cfg/compute_null_set.hpp"
#include "grail/include/cfg/compute_first_set.hpp"
#include "grail/include/cfg/compute_follow_set.hpp"

namespace grail { namespace cli {

    template <typename AlphaT>
    class CFG_INFO {
    public:

        FLTL_CFG_USE_TYPES(fltl::CFG<AlphaT>);

        static const char * const TOOL_NAME;

        static void declare(io::CommandLineOptions &opt, bool in_help) throw() {
            opt.declare("stats", io::opt::OPTIONAL, io::opt::NO_VAL);
            opt.declare("first", io::opt::OPTIONAL, io::opt::NO_VAL);
            opt.declare("follow", io::opt::OPTIONAL, io::opt::NO_VAL);
            opt.declare("null", io::opt::OPTIONAL, io::opt::NO_VAL);
            opt.declare("lead", io::opt::OPTIONAL, io::opt::NO_VAL);
            if(!in_help) {
                opt.declare_min_num_positional(1);
                opt.declare_max_num_positional(1);
            }
        }

        static void help(void) throw() {
            //  "  | |                              |                                             |"
            printf(
                "  %s:\n"
                "    Prints out information about a particular context-free grammar (CFG).\n\n"
                "  basic use options for %s:\n"
                "    --stats                        print out the number of variables, terminals,\n"
                "                                   variable terminals, and productions of the\n"
                "                                   grammar.\n"
                "    --first                        print out the FIRST set for every variable.\n"
                "    --follow                       print out the FOLLOW set for every variable.\n"
                "    --null                         print out the set of NULL variables (i.e. the\n"
                "                                   language generated by the variable contains\n"
                "                                   the empty string.)\n"
                "    --lead                         print ouf the LEAD set for every variable.\n"
                "    <file>                         read in a CFG from <file>.\n\n",
                TOOL_NAME, TOOL_NAME
            );
        }

        static int main(io::CommandLineOptions &options) throw() {

            // run the tool
            io::option_type file(options[0U]);
            const char *file_name(file.value());
            FILE *fp(fopen(file_name, "r"));
            FILE *out(stdout);

            if(0 == fp) {
                options.error(
                    "Unable to open file containing context-free "
                    "grammar for reading."
                );
                options.note("File specified here:", file);
                return 1;
            }

            cfg_type cfg;
            int ret(0);

            if(io::fread(fp, cfg, file_name)) {

                io::option_type opt_stats(options["stats"]);
                io::option_type opt_first(options["first"]);
                io::option_type opt_follow(options["follow"]);
                io::option_type opt_null(options["null"]);
                io::option_type opt_lead(options["lead"]);

                bool need_first(false), print_first(false);
                bool need_follow(false), print_follow(false);
                bool need_null(false), print_null(false);

                std::vector<bool> null_set;
                std::vector<std::vector<bool> *> first_sets;
                std::vector<std::vector<bool> *> follow_sets;

                if(opt_first.is_valid()) {
                    need_first = need_null = true;
                    print_first = true;
                }

                if(opt_follow.is_valid()) {
                    need_first = need_follow = need_null = true;
                    print_follow = true;
                }

                if(opt_null.is_valid()) {
                    need_null = true;
                    print_null = true;
                }

                if(need_null) {
                    cfg::compute_null_set(cfg, null_set);
                }

                if(need_first) {
                    cfg::compute_first_terminals(cfg, null_set, first_sets);
                }

                if(need_follow) {
                    cfg::compute_follow_set(cfg, null_set, first_sets, follow_sets);
                }

                variable_type V;
                terminal_type T;
                generator_type V_gen(cfg.search(~V));
                generator_type T_gen(cfg.search(~T));

                if(print_null) {
                    fprintf(out, "NULL Set:\n");
                    for(; V_gen.match_next(); ) {
                        if(null_set[V.number()]) {
                            fprintf(out, "\t");
                            io::fprint(out, cfg, V);
                            fprintf(out, "\n");
                        }
                    }
                    fprintf(out, "\n");
                }

                const char *set_names[] = {"FIRST", "FOLLOW"};
                std::vector<std::vector<bool> *> *sets[] = {
                    print_first ? &first_sets : 0,
                    print_follow ? &follow_sets : 0
                };

                for(int i = 0; i < 2; ++i) {
                    if(!sets[i]) {
                        continue;
                    }
                    fprintf(out, "%s Sets:\n", set_names[i]);
                    for(V_gen.rewind(); V_gen.match_next(); ) {
                        std::vector<bool> &set(*((*(sets[i]))[V.number()]));
                        fprintf(out, "\t%s(", set_names[i]);
                        io::fprint(out, cfg, V);
                        fprintf(out, ")\n");
                        for(T_gen.rewind(); T_gen.match_next(); ) {
                            if(set[T.number()]) {
                                fprintf(out, "\t\t");
                                io::fprint(out, cfg, T);
                                fprintf(out, "\n");
                            }
                        }
                    }
                    fprintf(out, "\n");
                }

                // TODO
                (void) opt_lead;
                (void) opt_stats;
                (void) need_first;
                (void) need_follow;
                (void) need_null;

            } else {
                ret = 1;
            }

            fclose(fp);

            return ret;
        }
    };

    template <typename AlphaT>
    const char * const CFG_INFO<AlphaT>::TOOL_NAME("cfg-info");
}}


#endif /* Grail_Plus_CFG_INFO_HPP_ */
