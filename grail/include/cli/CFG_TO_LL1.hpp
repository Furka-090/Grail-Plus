/*
 * CFG_TO_LL1.hpp
 *
 *  Created on: Jan 25, 2012
 *      Author: petergoodman
 *     Version: $Id$
 */

#ifndef Grail_Plus_CFG_TO_LL1_HPP_
#define Grail_Plus_CFG_TO_LL1_HPP_

#include <vector>
#include <utility>
#include <map>
#include <inttypes.h>
#include <stdint.h>
#include <climits>

#include "fltl/include/CFG.hpp"

#include "grail/include/cfg/compute_null_set.hpp"
#include "grail/include/cfg/compute_first_set.hpp"
#include "grail/include/cfg/compute_follow_set.hpp"

#include "grail/include/io/CommandLineOptions.hpp"
#include "grail/include/io/fread_cfg.hpp"
#include "grail/include/io/error.hpp"

#ifndef PRIu64
#   if UINT64_MAX > ULONG_MAX
#       define PRIu64 "llu"
#   else
#       define PRIu64 "lu"
#   endif
#endif

namespace grail { namespace cli {

    template <typename AlphaT>
    class CFG_TO_LL1 {
    public:

        FLTL_CFG_USE_TYPES(fltl::CFG<AlphaT>);

        static const char * const TOOL_NAME;

        static void declare(io::CommandLineOptions &opt, bool in_help) throw() {
            //io::option_type in(opt.declare("stdin", io::opt::OPTIONAL, io::opt::NO_VAL));
            if(!in_help) {
                opt.declare_min_num_positional(1);
                opt.declare_max_num_positional(1);
            }
        }

        static void help(void) throw() {
            //  "  | |                              |                                             |"
            printf(
                "  %s:\n"
                "    Computes the LL1 parser table for a Context-free Grammar (CFG) and outputs\n"
                "    a C++ program capable of parsing the language generated by the grammar, or\n"
                "    potentially a subset of the language because of first/first and first/follow\n"
                "    conflicts.\n\n"
                "  basic use options for %s:\n"
                "    <file>                         read in a CFG from <file>.\n\n",
                TOOL_NAME, TOOL_NAME
            );
        }

        static bool in_follow(
            std::vector<std::vector<bool> *> &follow,
            variable_type V, terminal_type a
        ) throw() {
            return (follow[V.number()])->at(a.number());
        }

        static const char *terminal_rep(cfg_type &cfg, terminal_type a) throw() {
            if(cfg.is_variable_terminal(a)) {
                return cfg.get_name(a);
            } else {
                return cfg.get_alpha(a);
            }
        }

        // try to make a meaningful report on how the issue came about.
        static void report_issue(
            cfg_type &cfg,
            production_type prod,
            terminal_type term,
            const std::vector<bool> &nullable,
            const std::vector<std::vector<bool> *> &first,
            const std::vector<std::vector<bool> *> &follow
        ) throw() {

            const char *prefix(0);

            // check to see if term is in the first set of prod
            symbol_string_type w(prod.symbols());
            for(unsigned i(0); i < w.length(); ++i) {
                if(w.at(i).is_variable()) {
                    variable_type v(w.at(i));

                    if(first[v.number()]->at(term.number())) {
                        fprintf(stderr,
                            "'%s' is in the first set of the variable '%s'.",
                            terminal_rep(cfg, term),
                            cfg.get_name(v)
                        );
                        prefix = cfg.get_name(v);

                        goto found;
                    }

                    // must be in the follow set
                    if(!nullable[v.number()]) {
                        break;
                    }

                } else if(w.at(i) == term) {
                    prefix = terminal_rep(cfg, term);
                    fprintf(stderr,
                        "'%s' appears in the production's right-hand side.",
                        prefix
                    );

                    goto found;
                }

                continue;

            found:
                if(i > 0) {
                    fprintf(stderr,
                        " The symbols before '%s' in the production's right-hand side are all nullable.",
                        prefix
                    );
                }

                fprintf(stderr, "\n");
                return;
            }

            // it's not in the first set, it must be in the follow set
            (void) follow;
            fprintf(stderr,
                "'%s' appears in follow set of '%s'.\n",
                terminal_rep(cfg, term),
                cfg.get_name(prod.variable())
            );
        }

        static void add_to_table(
            cfg_type &cfg,
            std::map<std::pair<unsigned, unsigned>, production_type> &table,
            variable_type V, terminal_type a, production_type p,
            const std::vector<bool> &nullable,
            const std::vector<std::vector<bool> *> &first,
            const std::vector<std::vector<bool> *> &follow
        ) throw() {
            std::pair<unsigned, unsigned> cell(V.number(), a.number());

            if(table.count(cell)) {
                production_type conflict(table[cell]);

                if(p == conflict) {
                    return;
                }

                io::warning(
                    "The following two productions conflict when trying to decide "
                    "which production of '%s' to parse on input '%s'. Production "
                    "#1 has been chosen.",
                    cfg.get_name(V),
                    terminal_rep(cfg, a)
                );

                fprintf(stderr, "         #0: ");
                io::fprint(stderr, cfg, p);
                fprintf(stderr, "         #1: ");
                io::fprint(stderr, cfg, conflict);

                fprintf(stderr, "\n         #0: ");
                report_issue(cfg, p, a, nullable, first, follow);
                fprintf(stderr, "         #1: ");
                report_issue(cfg, conflict, a, nullable, first, follow);
                fprintf(stderr, "\n");


            } else {
                //fprintf(stdout, "terminal '%s' for '%s' goes to (%u, %u): ", term, cfg.get_name(V), V.number(), a.number());
                //io::fprint(stdout, cfg, p);
                table[cell] = p;
                //printf("   new size = %lu\n", table.size());
            }
        }

        static bool all_nullable(
            std::vector<bool> &nullable,
            symbol_string_type ss
        ) throw() {
            for(unsigned i(0); i < ss.length(); ++i) {
                if(ss.at(i).is_terminal()) {
                    return false;
                }

                variable_type v(ss.at(i));
                if(!nullable[v.number()]) {
                    return false;
                }
            }
            return true;
        }

        static int main(io::CommandLineOptions &options) throw() {

            using fltl::CFG;

            FILE *fp(0);
            FILE *outfile(stdout);

            // run the tool
            io::option_type file(options[0U]);
            const char *file_name(file.value());
            fp = fopen(file_name, "r");

            if(0 == fp) {

                options.error(
                    "Unable to open file containing context-free "
                    "grammar for reading."
                );
                options.note("File specified here:", file);

                return 1;
            }

            char sep[] = {',', '\0', '\0'};

            int ret(0);
            cfg_type cfg;

            std::map<std::pair<unsigned, unsigned>, production_type> table;

            std::vector<bool> nullable;
            std::vector<std::vector<bool> *> first;
            std::vector<std::vector<bool> *> follow;

            // add numberings to the productions
            production_type prod;
            generator_type productions(cfg.search(~prod));

            // build the table, report errors as warnings and resolve in some
            // way or another
            variable_type A;
            terminal_type a;
            symbol_string_type w;
            generator_type As(cfg.search(~A));
            generator_type as(cfg.search(~a));
            generator_type A_related(cfg.search(~prod, A --->* ~w));
            std::vector<bool> empty_set;

            // can't bring in the cfg :(
            if(!io::fread(fp, cfg, file_name)) {
                ret = 1;
                goto done;
            }

            // empty set of all terminals
            empty_set.assign(cfg.num_terminals() + 2, false);

            grail::cfg::compute_null_set(cfg, nullable);
            grail::cfg::compute_first_set(cfg, nullable, first);
            grail::cfg::compute_follow_set(cfg, nullable, first, follow);

            for(; As.match_next(); ) {
                for(as.rewind(); as.match_next(); ) {
                    for(A_related.rewind(); A_related.match_next(); ) {

                        // easy case
                        if(w.is_empty()) {
                            if(in_follow(follow, A, a)) {
                                add_to_table(cfg, table, A, a, prod, nullable, first, follow);
                            }

                        // tricky case, need to check nullability
                        } else if(w.at(0).is_variable()) {

                            variable_type W(w.at(0));
                            std::vector<bool> *check_set(&empty_set);

                            // succeed quickly
                            if(!nullable[W.number()]) {
                                check_set = first[W.number()];

                            } else if(all_nullable(nullable, w)){
                                check_set = follow[W.number()];
                            }

                            if(check_set->at(a.number())) {
                                add_to_table(cfg, table, A, a, prod, nullable, first, follow);
                            }

                        // terminal, only care about if it's the one we want
                        } else if(w.at(0) == a) {
                            add_to_table(cfg, table, A, a, prod, nullable, first, follow);
                        }
                    }
                }
            }

            // output the file header
            fprintf(outfile,
                "// LL(1) parser, outputted by Grail+ (http://www.grailplus.org)\n"
                "#include <vector>\n"
                "#include <cassert>\n\n"
                "#define P(f) &p ## f\n"
                "#define NT(v) s.push_back(stack_symbol_type::non_terminal(v))\n"
                "#define T(t) s.push_back(stack_symbol_type::terminal(t))\n"
                "#define A(a) s.push_back(stack_symbol_type::action(a))\n"
                "\n"
                "// terminal id | terminal\n"
            );

            // print out all of the terminal mappings
            for(as.rewind(); as.match_next(); ) {
                fprintf(outfile,
                    "// %11u | %s\n",
                    a.number(), terminal_rep(cfg, a)
                );
            }

            fprintf(outfile,
                "\n"
                "typedef bool (action_type)(void);\n"
                "struct stack_symbol_type {\n"
                "    union {\n"
                "        unsigned t;\n"
                "        unsigned nt;\n"
                "        action_type *a;\n"
                "    } u;\n"
                "    enum stack_symbol_kind {\n"
                "        TERMINAL,\n"
                "        ACTION,\n"
                "        NON_TERMINAL\n"
                "    };\n"
                "    stack_symbol_kind k;\n"
                "    static stack_symbol_type terminal(unsigned t) throw() {\n"
                "        stack_symbol_type ss;\n"
                "        ss.k = TERMINAL;\n"
                "        ss.u.t = t;\n"
                "        return ss;\n"
                "    }\n"
                "    static stack_symbol_type non_terminal(unsigned nt) throw() {\n"
                "        stack_symbol_type ss;\n"
                "        ss.k = NON_TERMINAL;\n"
                "        ss.u.nt = nt;\n"
                "        return ss;\n"
                "    }\n"
                "    static stack_symbol_type action(action_type *a) throw() {\n"
                "        stack_symbol_type ss;\n"
                "        ss.k = ACTION;\n"
                "        ss.u.a = a;\n"
                "        return ss;\n"
                "    }\n"
                "};\n\n"
                "typedef std::vector<stack_symbol_type> stack_type;\n"
                "typedef bool (transition_type)(stack_type &);\n"
                ""
                "static bool perror(stack_type &) throw() {\n"
                "    return false;\n"
                "}\n\n"
            );

            // output all productions
            for(generator_type prods(cfg.search(~prod));
                prods.match_next(); ) {

                w = prod.symbols();

                fprintf(outfile, "// ");
                io::fprint(outfile, cfg, prod);
                fprintf(outfile,
                    "static bool p%" PRIu64 "(stack_type &s) throw() {\n",
                    prod.number()
                );

                // in case we're adding nothing to the stack
                if(0U == w.length()) {
                    fprintf(outfile, "    (void) s;\n");
                } else {
                    fprintf(outfile,
                        "    s.reserve(s.size() + %uU);\n",
                        w.length()
                    );
                }

                // add stuff to the stack in the reverse order that we're matching
                // so that the first thing to be matched is at the top of the
                // stack
                for(unsigned i(w.length()); i-- > 0U; ) {
                    if(w.at(i).is_variable()) {
                        A = w.at(i);
                        fprintf(outfile,
                            "    NT(%u); // %s\n",
                            A.number(),
                            cfg.get_name(A)
                        );
                    } else {
                        a = w.at(i);
                        fprintf(outfile,
                            "    T(%u); // %s\n",
                            a.number(),
                            terminal_rep(cfg, a)
                        );
                    }
                }

                fprintf(outfile,
                    "    return true;\n"
                    "}\n\n"
                );
            }

            fprintf(outfile,
                "static transition_type *trans[%u][%u] = {\n",
                cfg.num_variables_capacity(),
                cfg.num_terminals() + 1U
            );

            // transition table
            for(unsigned v(0); v < cfg.num_variables_capacity(); ++v) {
                fprintf(outfile, "    {");
                for(unsigned a(1), j(1); a < cfg.num_terminals() + 1U; ++a, j = 0) {
                    std::pair<unsigned, unsigned> cell(v, a);
                    if(table.count(cell)) {
                        fprintf(outfile, "%sP(%5" PRIu64 ")", &(sep[j]), table[cell].number());
                    } else {
                        fprintf(outfile, "%sP(error)", &(sep[j]));
                    }
                }
                fprintf(outfile, "},\n");
            }
            fprintf(outfile, "};\n\n");

            fprintf(outfile,
                "// parse some input stream\n"
                "template <typename token_stream_type, typename token_type>\n"
                "bool parse(token_stream_type &stream) throw() {\n"
                "    token_type tok;\n"
                "    stack_symbol_type sym;\n"
                "    stack_type s;\n"
                "    unsigned term;\n"
                "    NT(%u);\n"
                "    for(; stream.good(); ) {\n"
                "        assert(!s.empty());\n"
                "        stream >> tok;\n"
                "        term = (unsigned) tok;\n"
                "        sym = s.back();\n"
                "        s.pop_back();\n"
                "        if(stack_symbol_type::TERMINAL == sym.k) {\n"
                "            if(term != sym.u.t) {\n"
                "                return false;\n"
                "            }\n"
                "        } else if(stack_symbol_type::ACTION == sym.k) {\n"
                "            if(!sym.u.a()) {\n"
                "                return false;\n"
                "            }\n"
                "        } else {\n"
                "            trans[sym.u.nt][term](s);\n"
                "        }\n"
                "    }\n"
                "    return true;\n"
                "}\n\n",
                cfg.get_start_variable().number()
            );

        done:
            fclose(fp);
            fclose(outfile);

            // clean up

            table.clear();

            for(unsigned i(0); i < first.size(); ++i) {
                delete first[i];
                delete follow[i];

                first[i] = 0;
                follow[i] = 0;
            }

            first.clear();
            follow.clear();

            return ret;
        }
    };

    template <typename AlphaT>
    const char * const CFG_TO_LL1<AlphaT>::TOOL_NAME("cfg-to-ll1");
}}

#endif /* Grail_Plus_CFG_TO_LL1_HPP_ */
