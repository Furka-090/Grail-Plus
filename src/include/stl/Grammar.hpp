/*
 * Grammar.hpp
 *
 *  Created on: Sep 17, 2010
 *      Author: Peter Goodman
 *     Version: $Id$
 */

#ifndef CFTL_STL_GRAMMAR_HPP_
#define CFTL_STL_GRAMMAR_HPP_

#include <map>
#include <vector>

#include "src/include/mpl/Max.hpp"
#include "src/include/mpl/Sequence.hpp"
#include "src/include/mpl/Unit.hpp"

#include "src/include/preprocessor/TEMPLATE_VARIABLE_LIMIT.hpp"
#include "src/include/preprocessor/REPEAT_LEFT.hpp"
#include "src/include/preprocessor/STATIC_ASSERT.hpp"

#include "src/include/trait/PolyadicOperator.hpp"
#include "src/include/trait/Uncopyable.hpp"

#define CFTL_GRAMMAR_GET_OPERATOR_ARITY(n, _) \
    , (GrammarOperatorArity<\
           typename op_sequence_t::template At<n>::type_t \
       >::VALUE)

namespace cftl { namespace stl {

    namespace {
        template <typename T>
        class GrammarOperatorArity {
        public:
            enum {
                VALUE = T::ARITY
            };
        };

        template <>
        class GrammarOperatorArity<mpl::Unit> {
        public:
            enum {
                VALUE = 0
            };
        };
    }

    /// base grammar type.
    ///
    /// The base grammar template type imposes the following restrictions
    /// on its parameterized types:
    ///
    ///     - Parameter types must have default constructors, copy
    ///       constructors, and copy assignment operators. Terminal and
    ///       Non-terminal types are expected to behave with value semantics.
    ///     - The default construction of AcceptNonTermT must be the epsilon
    ///       non-terminal that accepts an empty word. By default,
    ///       AcceptNonTermT is NonTermT.
    ///     - the terminal and non-terminal types must have a well-defined
    ///       strict weak ordering. It does not matter if the orderings
    ///       imposed are not meaningful.
    ///
    /// The base grammar template type assumes the following:
    ///
    ///     - disjunction (defined by DisjunctionOperatorT) is a
    ///       commutative, associative, binary operator
    ///     - disjunction does not distribute over any of the non-disjunction
    ///       operators in OperatorSequenceT.
    ///     - disjunction has the lowest precedence of all operators used
    ///       in defining rewrite rules and so productions can be "split"
    ///       by occurrences of the disjunction operator without changing
    ///       the semantics of the grammar. The following transformation
    ///       must maintain the language generated by the grammar for all
    ///       valid rewrite rules W, X, Y, and Z:
    ///
    ///                  A : W | X   <==>  A  : W | $A | X
    ///                    | Y | Z         $A : X | Y
    ///
    template <
        // terminal type, e.g. character, token, etc.
        typename TermT,

        // non-terminal type, i.e. a rewrite rule type / production
        typename NonTermT,

        // disjunction operator; the grammar needs to know about disjunction.
        typename DisjunctionOperatorT,

        // sequence of unary and binary operators defined over TermT
        // and NonTermT.
        typename OperatorSequenceT,

        // empty non-terminal, i.e. epsilon
        typename AcceptNonTermT=NonTermT
    >
    class Grammar {
    private:

        typedef Grammar<
            TermT,
            NonTermT,
            DisjunctionOperatorT,
            OperatorSequenceT,
            AcceptNonTermT
        > self_t;

        typedef unsigned identifier_t;

        /// represents an identity operator for symbols,
        /// i.e. (non-)terminals
        class TerminalOperator : public trait::PolyadicOperator<1> { };
        class NonTerminalOperator : public trait::PolyadicOperator<1> { };

        /// make sure the disjunction and symbol operators are in the
        /// operator type sequence, and make sure that all types in the
        /// sequence are distinct.
        typedef typename OperatorSequenceT::UniqueTypes::type_t:: \
                template Insert<DisjunctionOperatorT>::type_t:: \
                template Insert<TerminalOperator>::type_t:: \
                template Insert<NonTerminalOperator>::type_t op_sequence_t;

        enum {

            /// number of operators, including disjunction and symbol
            /// identity
            NUM_OPERATORS = op_sequence_t::Length::VALUE,

            /// the maximum arity of all of the operators
            MAX_OPERATOR_ARITY = mpl::Max<
                NonTerminalOperator::ARITY
                CFTL_REPEAT_LEFT(
                    CFTL_TEMPLATE_VARIABLE_LIMIT,
                    CFTL_GRAMMAR_GET_OPERATOR_ARITY,
                    void
                )
            >::VALUE
        };

        /// internal representation of elements of a grammar
        class Expression {
        public:

            /// id of the operator
            unsigned operator_id;
            unsigned symbol_id;
            Expression *nodes[MAX_OPERATOR_ARITY];
        };

        /// the next id to be assigned for (non-)terminals.
        unsigned next_symbol_id[2];

        /// mappings of (non-)terminals to identifiers. the sets of
        /// mapped identifiers by these maps are disjoint
        std::map<TermT, const unsigned> terminal_map;
        std::map<NonTermT, const unsigned> non_terminal_map;

        /// mappings of non-terminals to expressions
        std::vector<Expression *> rules;

    public:

        /// class used for building up a single rewrite rule at runtime.
        /// the builder expects to be fed symbols (terminals, non-termianls)
        /// and operators in reverse-polish notation, i.e operands precede
        /// operators.
        class RuntimeProductionBuilder : private trait::Uncopyable {
        private:

            /// the grammar that owns this production builder
            self_t *owner;

            /// private constructor so that only a grammar can make
            /// production builders.
            RuntimeProductionBuilder(self_t &owned_by) throw()
             : owner(owned_by) { }

            /// push an identifier onto the stack.
            void push(const identifier_t id) {
                (void) id;
            }

        public:

            ~RuntimeProductionBuilder(void) throw() { }

            /// notify the production builder that stack can be collapsed
            /// by an operator
            template <typename RuleOperatorT>
            void collapse(void) {

                // make sure that the operator type passed in is actually
                // a valid operator for this grammar
                CFTL_STATIC_ASSERT(mpl::SizeOf<typename
                    op_sequence_t::template Select<RuleOperatorT>::type_t
                >::VALUE > 0);


            }

            void addTerminal(const TermT &symbol) {
                (void) symbol;
            }

            void addNonTerminal(const NonTermT &symbol) {
                (void) symbol;
            }
        };

        /// empty constructor
        Grammar(void) { }

        Grammar(const self_t &other)
         : terminal_map(other.terminal_map)
         , non_terminal_map(other.non_terminal_map) { }

        self_t &operator=(const self_t &other) {
            terminal_map = other.terminal_map;
            non_terminal_map = other.non_terminal_map;
        }

    };
}}

#endif /* CFTL_STL_GRAMMAR_HPP_ */
