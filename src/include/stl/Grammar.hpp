/*
 * Grammar.hpp
 *
 *  Created on: Sep 17, 2010
 *      Author: Peter Goodman
 *     Version: $Id$
 */

#ifndef CFTL_STL_GRAMMAR_HPP_
#define CFTL_STL_GRAMMAR_HPP_

#include <map>
#include <vector>

#include "src/include/mpl/Sequence.hpp"

namespace cftl { namespace stl {

    /// base grammar type.
    ///
    /// The base grammar template type imposes the following restrictions
    /// on its parameterized types:
    ///
    ///     - Parameter types must have default constructors, copy
    ///       constructors, and copy assignment operators.
    ///     - The default construction of AcceptNonTermT must be the epsilon
    ///       non-terminal that accepts an empty word. By default,
    ///       AcceptNonTermT is NonTermT.
    ///     - the terminal and non-terminal types must have a well-defined
    ///       strict weak ordering. It does not matter if the orderings
    ///       imposed are not meaningful.
    ///
    /// The base grammar template type assumes the following:
    ///
    ///     - disjunction (defined by DisjunctionOperatorT) is a
    ///       commutative, associative, binary operator
    ///     - disjunction does not distribute over any of the non-disjunction
    ///       operators in OperatorSequenceT.
    ///     - disjunction has the lowest precedence of all operators used
    ///       in defining rewrite rules and so productions can be "split"
    ///       by occurrences of the disjunction operator without changing
    ///       the semantics of the grammar. The following transformation
    ///       must maintain the language generated by the grammar for all
    ///       valid rewrite rules W, X, Y, and Z:
    ///
    ///                  A : W | X   <==>  A  : W | $A | X
    ///                    | Y | Z         $A : X | Y
    ///
    template <
        // terminal type, e.g. character, token, etc.
        typename TermT,

        // non-terminal type, i.e. a rewrite rule type / production
        typename NonTermT,

        // disjunction operator; the grammar needs to know about disjunction.
        typename DisjunctionOperatorT,

        // sequence of unary and binary operators defined over TermT
        // and NonTermT.
        typename OperatorSequenceT,

        // empty non-terminal, i.e. epsilon
        typename AcceptNonTermT=NonTermT
    >
    class Grammar {
    private:

        typedef Grammar<
            TermT,
            NonTermT,
            DisjunctionOperatorT,
            OperatorSequenceT,
            AcceptNonTermT
        > self_t;

        typedef unsigned identifier_t;

        /// make sure the disjunction operator is in the sequence type
        typedef typename OperatorSequenceT:: \
                template Insert<DisjunctionOperatorT>::type_t sequence_t;

        /// the next identifier to be assigned
        identifier_t next_identifier;

        /// mappings of (non-)terminals to identifiers. the sets of
        /// mapped identifiers by these maps are disjoint
        std::map<TermT, const identifier_t> terminal_map;
        std::map<NonTermT, const identifier_t> non_terminal_map;

    public:

        /// class used for building up production rewrite rules.
        class ProductionBuilder {
        private:
        public:
        };


        Grammar(void) { }

        Grammar(const self_t &other)
         : terminal_map(other.terminal_map)
         , non_terminal_map(other.non_terminal_map) { }

        self_t &operator=(const self_t &other) {
            terminal_map = other.terminal_map;
            non_terminal_map = other.non_terminal_map;
        }

    };
}}

#endif /* CFTL_STL_GRAMMAR_HPP_ */
